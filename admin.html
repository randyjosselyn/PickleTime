/**** CONFIG (edit these if your tab names differ) ****/
const DATA_SHEET     = 'Sheet1';   // data rows
const ROSTER_SHEET   = 'Roster';   // Player, Division
const SETTINGS_SHEET = 'Settings'; // Key, Value (SeasonStart, SeasonEnd)
const GAMEDAYS_SHEET = 'GameDays'; // Date, Division, IsBye, Start, CoachNote

/**** HELPERS ****/
function ss_(){ return SpreadsheetApp.getActiveSpreadsheet(); }
function sh_(name){ const s=ss_().getSheetByName(name); if(!s) throw new Error('Sheet not found: '+name); return s; }

function readTable_(sheetName){
  const sh=sh_(sheetName), v=sh.getDataRange().getValues();
  if(!v.length) return {headers:[],rows:[]};
  const headers=v[0]; const rows=v.slice(1).map(r=>{const o={}; headers.forEach((h,i)=>o[h]=r[i]); return o;});
  return {headers, rows};
}

function readSettings_(){
  const {headers, rows} = readTable_(SETTINGS_SHEET);
  const out={}; rows.forEach(r=>{ out[r['Key']] = r['Value']; });
  return out;
}

function ensureHeaders_(){
  // Run once if you need to stamp headers
  sh_(DATA_SHEET).getRange(1,1,1,12).setValues([[
    'Timestamp','Player','Division','Type','Practice Date','Day',
    'Practice: 6-8 AM','Practice: 8-10 AM','Practice: 12-2 PM','Practice: 7-10 PM',
    'Game Date','Available for Game?'
  ]]);
  sh_(ROSTER_SHEET).getRange(1,1,1,2).setValues([['Player','Division']]);
  sh_(SETTINGS_SHEET).getRange(1,1,1,2).setValues([['Key','Value']]);
  sh_(GAMEDAYS_SHEET).getRange(1,1,1,5).setValues([['Date','Division','IsBye','Start','CoachNote']]);
}

/**** ROSTER ****/
function readRoster_(division){
  const {headers, rows} = readTable_(ROSTER_SHEET);
  const hasDiv = headers.includes('Division');
  let list = rows
    .map(r => ({
      player: (r['Player']||'').toString().trim(),
      division: hasDiv ? (r['Division']||'').toString().trim().toUpperCase() : ''
    }))
    .filter(x => x.player);

  if (division) {
    // Fallback: if Division is missing/blank on a row, treat it as the requested division
    list = list.filter(x => (x.division || division).toUpperCase() === division.toUpperCase());
  }
  return list;
}

function upsertRoster_(player, division){
  const sh = sh_(ROSTER_SHEET);
  const {headers, rows} = readTable_(ROSTER_SHEET);
  const pIdx=headers.indexOf('Player');
  const dIdx=headers.indexOf('Division');
  if (pIdx===-1) throw new Error('Roster missing "Player" header');
  if (dIdx===-1) {
    // add Division header
    sh.getRange(1, headers.length+1, 1, 1).setValues([['Division']]);
  }
  const all = readTable_(ROSTER_SHEET); // refresh
  const headers2 = all.headers; const rows2 = all.rows;
  const find = rows2.findIndex(r => (r['Player']||'').toString().trim().toUpperCase() === player.toUpperCase());
  const values = headers2.map(h => {
    if (h==='Player') return player;
    if (h==='Division') return (division||'').toUpperCase();
    return '';
  });
  if (find===-1) {
    sh.appendRow(values);
  } else {
    sh.getRange(find+2, 1, 1, headers2.length).setValues([values]);
  }
  return true;
}

function deleteRosterPlayer_(player){
  const sh=sh_(ROSTER_SHEET);
  const {headers, rows} = readTable_(ROSTER_SHEET);
  const idx = rows.findIndex(r => (r['Player']||'').toString().trim().toUpperCase() === player.toUpperCase());
  if (idx>-1) { sh.deleteRow(idx+2); return true; }
  return false;
}

/**** GAMEDAYS (per Division) ****/
function readGameDays_(division){
  const {rows} = readTable_(GAMEDAYS_SHEET);
  return rows
    .filter(r => (r['Division']||'').toString().trim().toUpperCase() === (division||'').toString().trim().toUpperCase())
    .map(r => ({
      Date: (r['Date']||'').toString().trim(),
      Division: (r['Division']||'').toString().trim().toUpperCase(),
      IsBye: ((r['IsBye']||'').toString().trim().toLowerCase()==='yes') ? 'Yes':'No',
      Start: (r['Start']||'').toString().trim(),
      CoachNote: (r['CoachNote']||'').toString().trim()
    }));
}

function upsertGameDay_(dateISO, division, isBye, start, note){
  const sh=sh_(GAMEDAYS_SHEET);
  const {headers, rows} = readTable_(GAMEDAYS_SHEET);
  // Ensure headers
  const need = ['Date','Division','IsBye','Start','CoachNote'].filter(h => !headers.includes(h));
  if (need.length){
    sh.getRange(1, headers.length+1, 1, need.length).setValues([need]);
  }
  const all = readTable_(GAMEDAYS_SHEET);
  const rows2 = all.rows; const headers2=all.headers;
  // Find existing row matching Date+Division
  const idx = rows2.findIndex(r =>
    (r['Date']||'').toString().trim() === dateISO &&
    (r['Division']||'').toString().trim().toUpperCase() === division.toUpperCase()
  );
  const values = headers2.map(h => {
    if (h==='Date') return dateISO;
    if (h==='Division') return division.toUpperCase();
    if (h==='IsBye') return isBye ? 'Yes':'No';
    if (h==='Start') return isBye ? '' : (start||'');
    if (h==='CoachNote') return note||'';
    return '';
  });
  if (idx===-1){
    sh.appendRow(values);
  } else {
    sh.getRange(idx+2, 1, 1, headers2.length).setValues([values]);
  }
}

/**** API ENDPOINTS ****/
function doGet(e){
  return ContentService.createTextOutput('OK').setMimeType(ContentService.MimeType.TEXT);
}

function doPost(e){
  let data={}; try{ data=JSON.parse(e.postData.contents); }catch(_){}
  const action=(data.action||'').toLowerCase();
  const division=(data.division||'').toString().trim().toUpperCase();

  // ----- READERS -----
  if (action==='roster'){
    return json_({ status:'success', roster: readRoster_(division) });
  }

  if (action==='read'){
    const rowsPayload = readTable_(DATA_SHEET);
    const settings = readSettings_();
    const gamedays = division ? readGameDays_(division) : [];
    return json_({
      status:'success',
      ...rowsPayload,
      roster: readRoster_(division),
      settings,
      gamedays,
      updatedAt: new Date().toISOString()
    });
  }

  if (action==='getsettings'){
    return json_({ status:'success', settings: readSettings_(), gamedays: readGameDays_(division) });
  }

  // ----- WRITE: Settings, GameDays -----
  if (action==='savesettings'){
    const s=data.settings||{};
    Object.keys(s).forEach(k=>{
      const sh=sh_(SETTINGS_SHEET);
      const {headers,rows}=readTable_(SETTINGS_SHEET);
      const idx=rows.findIndex(r => (r['Key']||'')===k);
      if (!headers.includes('Key') || !headers.includes('Value')){
        sh.getRange(1,1,1,2).setValues([['Key','Value']]);
      }
      if (idx===-1){
        sh.appendRow([k, s[k]||'']);
      } else {
        sh.getRange(idx+2,1,1,2).setValues([[k, s[k]||'']]);
      }
    });
    return json_({ status:'success', settings: readSettings_() });
  }

  if (action==='setgameday'){
    // expects: { date, division, isBye, start, coachNote }
    upsertGameDay_(data.date, division, !!data.isBye, data.start||'', data.coachNote||'');
    return json_({ status:'success', gamedays: readGameDays_(division) });
  }

  // ----- WRITE: Roster -----
  if (action==='addplayer'){
    if (!data.player) return json_({ status:'error', message:'Player required' }, 400);
    upsertRoster_(data.player, (data.division||''));
    return json_({ status:'success', roster: readRoster_(division) });
  }

  if (action==='removeplayer'){
    if (!data.player) return json_({ status:'error', message:'Player required' }, 400);
    deleteRosterPlayer_(data.player);
    return json_({ status:'success', roster: readRoster_(division) });
  }

  if (action==='updateplayerdivision'){
    if (!data.player) return json_({ status:'error', message:'Player required' }, 400);
    upsertRoster_(data.player, (data.division||''));
    return json_({ status:'success', roster: readRoster_(division) });
  }

  // ----- WRITE: Practice (week) & Game availability -----
  if (action==='submitweek'){
    const week = Array.isArray(data.week) ? data.week : [];
    const sh=sh_(DATA_SHEET);
    const rows = week.map(it=> ([
      new Date(),
      data.player||'',
      division||'',
      'practice',
      it?.date||'',
      it?.day||'',
      it?.p68 ? 'Yes':'',
      it?.p810? 'Yes':'',
      it?.p122? 'Yes':'',
      it?.p710? 'Yes':'',
      '',
      ''
    ]));
    if (rows.length) sh.getRange(sh.getLastRow()+1,1,rows.length,rows[0].length).setValues(rows);
    return json_({ status:'success', inserted: rows.length });
  }

  if (action==='submitgame'){
    const sh=sh_(DATA_SHEET);
    sh.appendRow([
      new Date(), data.player||'', division||'',
      'game','', '', '', '', '', '',
      data.game_date||'', data.game_available||''
    ]);
    return json_({ status:'success' });
  }

  // Default
  return json_({ status:'success' });
}

function json_(obj, code){
  return ContentService.createTextOutput(JSON.stringify(obj))
    .setMimeType(ContentService.MimeType.JSON);
}

/**** UTIL: bulk set blank divisions (run once if needed) ****/
function assignBlankDivisions_(defaultDiv){
  const sh=sh_(ROSTER_SHEET);
  const {headers, rows} = readTable_(ROSTER_SHEET);
  let changed=0;
  const pIdx=headers.indexOf('Player');
  let dIdx=headers.indexOf('Division');
  if (dIdx===-1){
    sh.getRange(1, headers.length+1, 1, 1).setValues([['Division']]);
    dIdx = headers.length; // after refresh, but weâ€™ll operate directly on sheet
  }
  const last = sh.getLastRow();
  for (let i=0;i<rows.length;i++){
    const div = (rows[i]['Division']||'').toString().trim();
    if (!div){
      sh.getRange(i+2, headers.indexOf('Division')+1).setValue((defaultDiv||'D4').toUpperCase());
      changed++;
    }
  }
  return `Updated ${changed} rows`;
}
